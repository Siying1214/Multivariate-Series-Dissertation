library(FinTS)
library(rugarch)
library(copula)
library(ks)
library(rgl)
library(dplyr)
library(tidyr)
library(lubridate)
library(tsibble)
library(tibble)
library(ggplot2)
library(patchwork)
library(GGally)

# Read & preprocess data
fx_data <- readr::read_csv("Excahnge Rates vs USD.csv", na = c("", "NA")) %>%
  dplyr::rename(Date = 1) %>%
  dplyr::mutate(Date = lubridate::dmy(Date)) %>%
  tsibble::as_tsibble(index = Date) %>%
  tsibble::fill_gaps() %>%
  tidyr::fill(c(GBP, AUD, CHF), .direction = "downup")

# Extract GBP and compute log returns
gbp_data <- fx_data %>%
  dplyr::select(Date, GBP) %>%
  dplyr::mutate(log_ret_GBP = log(GBP) - log(dplyr::lag(GBP))) %>%
  tidyr::drop_na()

# Extract AUD and compute log returns
aud_data <- fx_data %>%
  dplyr::select(Date, AUD) %>%
  dplyr::mutate(log_ret_AUD = log(AUD) - log(dplyr::lag(AUD))) %>%
  tidyr::drop_na()

# Extract CHF and compute log returns
chf_data <- fx_data %>%
  dplyr::select(Date, CHF) %>%
  dplyr::mutate(log_ret_CHF = log(CHF) - log(dplyr::lag(CHF))) %>%
  tidyr::drop_na()

# Plot GBP log-return time series
p1 <- ggplot(gbp_data, aes(x = Date, y = log_ret_GBP)) +
  geom_line(color = "blue", size = 0.5) +
  labs(title = "GBP/USD Log Returns",
       x = "Date",
       y = "Log Return") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
# Plot AUD log-return time series
p2 <- ggplot(aud_data, aes(x = Date, y = log_ret_AUD)) +
  geom_line(color = "red", size = 0.5) +
  labs(title = "AUD/USD Log Returns",
       x = "Date",
       y = "Log Return") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Plot CHF log-return time series
p3 <- ggplot(chf_data, aes(x = Date, y = log_ret_CHF)) +
  geom_line(color = "darkgreen", size = 0.5) +
  labs(title = "CHF/USD Log Returns",
       x = "Date",
       y = "Log Return") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Combine the three plots (vertically)
combined_plot <- p1 / p2 / p3  # patchwork composition syntax

# Split train and test sets (by date)
train_set_GBP <- gbp_data %>%
  filter(Date >= ymd("2023-10-01") & Date <= ymd("2025-03-16"))
test_set_GBP <- gbp_data %>%
  filter(Date >= ymd("2025-03-17") & Date <= ymd("2025-04-30"))

train_set_AUD <- aud_data %>%
  filter(Date >= ymd("2023-10-01") & Date <= ymd("2025-03-16"))
test_set_AUD <- aud_data %>%
  filter(Date >= ymd("2025-03-17") & Date <= ymd("2025-04-30"))

train_set_CHF <- chf_data %>%
  filter(Date >= ymd("2023-10-01") & Date <= ymd("2025-03-16"))
test_set_CHF <- chf_data %>%
  filter(Date >= ymd("2025-03-17") & Date <= ymd("2025-04-30"))

# Fit ARMA models
arma_model_fit_gbp <- arima(x = train_set_GBP$log_ret_GBP, order = c(0,0,0), include.mean = F)
arma_model_fit_aud <- arima(x = train_set_AUD$log_ret_AUD, order = c(0,0,0), include.mean = F)
arma_model_fit_chf <- arima(x = train_set_CHF$log_ret_CHF, order = c(0,0,0), include.mean = F)
# Extract residuals
resid_gbp <- residuals(arma_model_fit_gbp)
resid_aud <- residuals(arma_model_fit_aud)
resid_chf <- residuals(arma_model_fit_chf)
# --- Plot ACF of standardized residuals ---
dev.new()  # draw in a new graphics window
acf(as.numeric(resid_chf^2), lag.max = 25,
    main = "ACF plot for Squared Residuals from ARMA(0,0) (CHF)",
    xlab = "Lag", ylab = "ACF")
cat("\nACF of standardized residuals plotted in a new graphics window.\n")

# Run ARCH tests
ArchTest(resid_gbp, lags = 10)  # ARCH test for GBP
ArchTest(resid_aud, lags = 10)  # ARCH test for AUD
ArchTest(resid_chf, lags = 10)  # ARCH test for CHF


# Build ARMA+GARCH model (model form can be changed anytime)
spec_arima_garch <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(0, 2)),
  mean.model = list(armaOrder = c(0, 0), include.mean = FALSE),
  distribution.model = "std"  # can be "norm", "ged", or "sstd"
)

# Extract training-set log returns for GBP
train_logret_gbp <- train_set_GBP$log_ret_GBP

# Extract training-set log returns for AUD
train_logret_aud <- train_set_AUD$log_ret_AUD

# Extract training-set log returns for CHF
train_logret_chf <- train_set_CHF$log_ret_CHF
# Fit models
fit_garch_gbp <- ugarchfit(spec = spec_arima_garch, data = train_logret_gbp)

fit_garch_aud <- ugarchfit(spec = spec_arima_garch, data = train_logret_aud)

fit_garch_chf <- ugarchfit(spec = spec_arima_garch, data = train_logret_chf)
# Print results
print(fit_garch_gbp)

print(fit_garch_aud)

print(fit_garch_chf)


# Extract standardized residuals
resid_gbp_garch <- residuals(fit_garch_gbp, standardize = TRUE)
resid_aud_garch <- residuals(fit_garch_aud, standardize = TRUE)
resid_chf_garch <- residuals(fit_garch_chf, standardize = TRUE)

# --- Plot ACF: standardized residuals ---
dev.new()  # draw in a new graphics window
acf(as.numeric(resid_gbp_garch^2), lag.max = 25,
    main = "ACF of Standardized Squared Residuals from GARCH(1,1) Model(GBP)",
    xlab = "Lag", ylab = "ACF")
cat("\nACF of standardized residuals plotted in a new graphics window.\n")

# Define a function for Q-Q plots
qq_plot_normal <- function(resid, title_text) {
  n <- length(resid)
  p <- ppoints(n)
  theoretical <- qnorm(p)  # theoretical quantiles (Normal)
  sample <- sort(as.numeric(resid))
  
  df_plot <- data.frame(
    Theoretical = theoretical,
    Sample = sample
  )
  
  ggplot(df_plot, aes(x = Theoretical, y = Sample)) +
    geom_point(color = "black", size = 1.5, alpha = 0.7) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
    labs(title = paste("Q-Q Plot of Standardized Residuals:", title_text),
         x = "Theoretical Quantiles (Normal)",
         y = "Sample Quantiles") +
    theme_minimal()
}

# Draw Q-Q plots for GBP, AUD, and CHF
qq_plot_normal(resid_gbp_garch, "GBP")
qq_plot_normal(resid_aud_garch, "AUD")
qq_plot_normal(resid_chf_garch, "CHF")

# Extract the 'shape' (degrees of freedom) parameter for GBP (you can modify to plot for the other two)
df_gbp <- coef(fit_garch_gbp)["shape"]

# Manually generate Q-Q data (t distribution)
qq_data_gbp <- function(resid, df) {
  n <- length(resid)
  p <- ppoints(n)
  theoretical <- qt(p, df = df)
  data.frame(
    Theoretical = theoretical,
    Sample = sort(as.numeric(resid))
  )
}

# Create the Q-Q plot (t distribution)
qq_gbp_plot <- function(resid, df) {
  df_plot <- qq_data_gbp(resid, df)
  ggplot(df_plot, aes(x = Theoretical, y = Sample)) +
    geom_point(color = "black") +
    geom_abline(slope = 1, intercept = 0, color = "red") +
    labs(title = "Q-Q plot of log returns with t distribution",
         x = "Theoretical Quantiles",
         y = "Sample Quantiles") +
    theme_minimal()
}

# Create the histogram
hist_gbp_plot <- function(resid) {
  df_plot <- data.frame(Residuals = resid)
  ggplot(df_plot, aes(x = Residuals)) +
    geom_histogram(aes(y = ..density..), bins = 30, fill = "#4B9CD3", color = "black", alpha = 0.7) +
    geom_density(color = "darkred", size = 1) +
    labs(title = "Histogram of Standardised Residuals: CHF",
         x = "Residuals",
         y = "Density") +
    theme_minimal()
}

# Plot objects
p1 <- qq_gbp_plot(resid_gbp_garch, df_gbp)
p2 <- hist_gbp_plot(resid_gbp_garch)


# Convert to data.frame and unify into one table
std_resid_df <- tibble::tibble(
  Date = train_set_GBP$Date,  # training-set dates are the same across currencies
  GBP = as.numeric(resid_gbp_garch),
  AUD = as.numeric(resid_aud_garch),
  CHF = as.numeric(resid_chf_garch)
)

# View correlation matrix
cor_matrix <- cor(std_resid_df[, -1])  # drop Date column
print(cor_matrix)

# Pairwise relationships among standardized residuals of the three currencies
GGally::ggpairs(std_resid_df[, -1], 
                title = "Standardised Residuals Correlation Matrix")


# Scatter: GBP vs AUD
plot(std_resid_df$GBP, std_resid_df$AUD,
     xlab = "Standardized Residuals: GBP",
     ylab = "Standardized Residuals: AUD",
     main = "Scatter Plot: GBP vs AUD",
     pch = ".", cex = 2.5)

# Scatter: GBP vs CHF
plot(std_resid_df$GBP, std_resid_df$CHF,
     xlab = "Standardized Residuals: GBP",
     ylab = "Standardized Residuals: CHF",
     main = "Scatter Plot: GBP vs CHF",
     pch = ".", cex = 2.5)

# Scatter: AUD vs CHF
plot(std_resid_df$AUD, std_resid_df$CHF,
     xlab = "Standardized Residuals: AUD",
     ylab = "Standardized Residuals: CHF",
     main = "Scatter Plot: AUD vs CHF",
     pch = ".", cex = 2.5)

# Merge into a 3D matrix
sim.data3 <- cbind(resid_gbp_garch, resid_aud_garch, resid_chf_garch)
colnames(sim.data3) <- c("GBP", "AUD", "CHF")
sim.data3 <- as.matrix(sim.data3)
# Estimate bandwidth matrix (H)
Hpi_3d <- Hpi(x = sim.data3, pilot = "samse", nstage = 2, pre = "scale")

# KDE fitting
fhat3d <- kde(x = sim.data3, H = Hpi_3d)

# 3D visualization of KDE (rotate to view joint distribution)
plot(fhat3d, display = "rgl", cont = c(10, 25, 50, 75, 90))

sim.data2 <- cbind(resid_aud_garch, resid_chf_garch)
sim.data2 <- as.matrix(sim.data2)
Hpi_2d <- Hpi(sim.data2)
fhat2d <- kde(sim.data2, H = Hpi_2d)

# Plot
plot(fhat2d, 
     cont = c(10, 25, 50, 75, 90), 
     col = rainbow(5),  # vivid colors
     main = "2D KDE contour plot of AUD vs CHF",
     xlab = "AUD returns", 
     ylab = "CHF returns")
points(sim.data2[,1], sim.data2[,2], pch = ".", cex = 1.5)


# Create standardized residual matrix
my.std.data <- as.data.frame(sim.data3)
colnames(my.std.data) <- c("GBP", "AUD", "CHF")

np_copula = function(i, j) {
  uv <- my.std.data[, c(i, j)]
  n <- nrow(uv)
  uv <- cbind(rank(uv[,1]), rank(uv[,2])) / (n + 1)
  xy <- qnorm(uv)
  s <- 0.5
  
  vx <- seq(1/30, 29/30, by = 1/30)
  xname <- colnames(my.std.data)[i]
  yname <- colnames(my.std.data)[j]
  
  # ---------- Nonparametric copula ----------
  dc_np <- Vectorize(function(x, y)
    mean(dnorm(rep(qnorm(x), n), xy[,1], s) *
           dnorm(rep(qnorm(y), n), xy[,2], s)) /
      (dnorm(qnorm(x)) * dnorm(qnorm(y)))
  )
  vz_np <- outer(vx, vx, dc_np)
  par(mar = c(3, 3, 5, 2))
  persp(vx, vx, vz_np,
        theta = 30, phi = 25, expand = 0.6,
        col = "lightblue", shade = 0.5,
        ticktype = "detailed", zlim = range(vz_np, finite = TRUE),
        xlab = xname, ylab = yname, zlab = "Nonparametric Copula",
        cex.lab = 0.8, cex.axis = 0.7, ltheta = 135, r = 3)
  mtext(paste("Nonparametric Copula for", xname, "vs", yname),
        side = 3, line = 2.5, cex = 1, font = 2)
  
  # ---------- Gaussian copula ----------
  library(copula)
  norm.cop <- normalCopula(0.5, dim = 2)
  fit_norm <- fitCopula(norm.cop, uv, method = "ml")
  norm.cop <- normalCopula(fit_norm@estimate, dim = 2)
  loglik_norm <- logLik(fit_norm)
  aic_norm <- -2 * loglik_norm + 2 * 1
  bic_norm <- -2 * loglik_norm + log(n) * 1
  dc_gauss <- function(x, y) dCopula(cbind(x, y), norm.cop)
  vz_gauss <- outer(vx, vx, dc_gauss)
  par(mar = c(3, 3, 5, 2))
  persp(vx, vx, vz_gauss,
        theta = 35, phi = 25, expand = 0.5,
        col = "bisque", shade = 0.5,
        ticktype = "detailed", zlim = range(vz_gauss, finite = TRUE),
        xlab = xname, ylab = yname, zlab = "Gaussian Copula",
        cex.lab = 0.7, cex.axis = 0.6, ltheta = 135, r = 3)
  mtext(paste("Gaussian Copula for", xname, "vs", yname),
        side = 3, line = 2.5, cex = 1, font = 2)
  cat("Gaussian Copula:\n")
  cat("  Log-likelihood:", loglik_norm, "\n")
  cat("  AIC:", aic_norm, "\n")
  cat("  BIC:", bic_norm, "\n\n")
  
  # ---------- Student-t copula ----------
  t.cop <- tCopula(0.5, df = 4, dim = 2)
  fit_t <- fitCopula(t.cop, uv, method = "ml")
  t.fit <- fit_t@estimate
  t.cop <- tCopula(t.fit[1], df = t.fit[2], dim = 2)
  loglik_t <- logLik(fit_t)
  aic_t <- -2 * loglik_t + 2 * 2
  bic_t <- -2 * loglik_t + log(n) * 2
  dc_t <- function(x, y) dCopula(cbind(x, y), t.cop)
  vz_t <- outer(vx, vx, dc_t)
  par(mar = c(3, 3, 5, 2))
  persp(vx, vx, vz_t,
        theta = 35, phi = 25, expand = 0.5,
        col = "lightgreen", shade = 0.5,
        ticktype = "detailed", zlim = range(vz_t, finite = TRUE),
        xlab = xname, ylab = yname, zlab = "Student-t Copula",
        cex.lab = 0.7, cex.axis = 0.6, ltheta = 135, r = 3)
  mtext(bquote("t Copula for" ~ .(xname) ~ "vs" ~ .(yname) ~ 
                 "," ~ rho == .(round(t.fit[1], 2)) ~ "," ~ df == .(round(t.fit[2], 2))),
        side = 3, line = 2.5, cex = 1, font = 2)
  cat("Student-t Copula:\n")
  cat("  Fitted parameters: rho =", t.fit[1], ", df =", t.fit[2], "\n")
  cat("  Log-likelihood:", loglik_t, "\n")
  cat("  AIC:", aic_t, "\n")
  cat("  BIC:", bic_t, "\n")
}

np_copula(1,2)  # GBP vs AUD
np_copula(1,3)  # GBP vs CHF
np_copula(2,3)  # AUD vs CHF
